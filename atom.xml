<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Demiazz Harbor]]></title>
  <link href="http://demiazz.github.com/atom.xml" rel="self"/>
  <link href="http://demiazz.github.com/"/>
  <updated>2011-12-02T01:21:06+04:00</updated>
  <id>http://demiazz.github.com/</id>
  <author>
    <name><![CDATA[Алексей Плуталов]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Краткий отчет с HTML5 Camp]]></title>
    <link href="http://demiazz.github.com/blog/2011/12/01/kratkii-otchiet-s-html5-camp/"/>
    <updated>2011-12-01T23:50:00+04:00</updated>
    <id>http://demiazz.github.com/blog/2011/12/01/kratkii-otchiet-s-html5-camp</id>
    <content type="html"><![CDATA[<p>Вчера прошла конференция HTML5 Camp, устроенная компанией Microsoft. Мне
удалось лично побывать на ней, и послушать докладчиков. Кратко опишу,
что было, свои впечатления и выводы, которые я сделал по окончании
конференции.</p>

<!-- more -->


<h2>Как это было?</h2>

<p>Было это классно. На деле, я ждал этой конференции наверное недели две с
нетерпением, чтобы наконец там побывать.</p>

<p>С самого утра, все собирались у метро Приморская, где участников
конференции встречала event-команда. Все было организованно, и красиво.
Людей собирали, и на автобусах отвозили в гостиницу Park Inn
Прибалтийская, где собственно и проходила конференция.</p>

<p>Всех участников на входе организованно провожали на регистрацию,
выдавали надлежащий стафф в виде рекламных буклетов от MS, и
стандартного блокнота и ручки, и анкеты участника для оценки
конференции.</p>

<p>Пока все собирались, участникам был устроен кофебрейк с печеньками,
интерактивными залами, где например, можно было попробовать себя в
дартс, а в качестве мишени висел значок Internet Explorer 6, и конечно
же делали памятные фото.</p>

<p>Так как на конференции я был один, то наблюдал за народом со стороны,
дожидаясь собственно начала конференции.</p>

<p>Конференция проходила в большом пленарном зале. Открывали конференцию
Александр Ложечкин (директор Департамента стратегических технологий
Microsoft в России), и Николай Прянишников (президент Microsoft в
России).</p>

<p>Александр красиво и подробно изложил как цели конференции, так и в общих
чертах складывающуюся ситуацию в сфере веб-разработки, и в частности,
что она влечет за собой.</p>

<p>Краткое выступление же Николая Прянишникова не порадовало особо, так как
было похоже на какую-то рекламную акцию, хотя надо отдать должное, так
как Microsoft является организатором.</p>

<p>После часового открытия конференции, все дождались выступления
специального гостя из далекого США Бенжамина Лившица (исследователь из
Microsoft Research).</p>

<p>Доклад был весьма технический, но поднимаемый вопрос - не менее важный. Несмотря на то, что
Бен отлично говорит по русски, доклад все же был на английском, очень
содержательным и подробным.</p>

<p>Тема приватности и безопасности в интернете сейчас очень актуальна и
важна, кроме того обсуждались возможности сбора информации о
пользователях, и способы ее обработки. В общих чертах конечно.</p>

<p>Сказать более подробно что-то увы не смогу, так как меня просто вырубало
в сон (да, мне стыдно, но видимо сказался недосып).</p>

<p>Далее, во время перерыва зал разделили на два конференц-зала, для
продолжения конференции по интересам.</p>

<h3>&#8220;Фанаты Javascript, я не вижу ваших рук!&#8221; &copy; Гайдар Магдануров</h3>

<p>Я остался слушать доклад Гайдара Магданурова о Node.js на Windows. По
поводу доклада. Доклад был предназначен скорее для тех, кто не знаком с
Node.js, и честно сказать, тема Windows в докладе почти не
присутствовала, так как сам доклад выглядел как демонстрация
возможностей.</p>

<p>Что порадовало, так это то, что Node.js уже работает под Windows, хотя
когда-то это было очень проблемно.</p>

<p>Как показал краткий опрос проведенный Гайдаром, среди участников, мало
кто слышал о Node.js, и еще меньше использовали его в production, что
честно говоря меня удивило. Я надеялся увидеть лес рук, но его не было.</p>

<p>Помимо всего, в докладе, Гайдар пожаловался на слабые стороны Node.js
(действительно, отладка с дебаггером - это очень страшное занятие), ведь
на Windows до сих пор не поддерживается Node Inspector.</p>

<p>Ну и также, посмеялись над фанатами Javascript. В зале оказался всего
лишь один фанат.</p>

<p>Доклад был очень показательным, и полным для демонстрации, и очень
хорошо приправленных харизматичностью Гайдара, который не давал
слушателям скучать. Честно сказать, покидал я доклад с очень большой
грустью, потому что хотелось еще. Не каждому дано интересно и красиво
выступать с докладами, чтобы это было интересно.</p>

<p>Вместе со мной, зал покинуло большинство людей, несмотря на то, что
следующим докладом в первом зале был доклад Бена Лившица, и снова о
безопасности. Видимо таки, многие пришли посмотреть и послушать про
новые возможности HTML5.</p>

<h3>Открой Chrome</h3>

<p>Следующим докладом был &#8220;От уголков до анимаций: погружение в новые
возможности CSS3&#8221; от Константина Кичинского. Лично для меня доклад был
не особо информативным, так как демонстрировались базовые возможности
CSS3, которые я уже давно стараюсь использовать везде где только можно,
отчасти потому что, это действительно удобно, отчасти потому, что я
хреновый художник, и в глаза Photoshop в жизни видел наверное пару раз.</p>

<p>Сам доклад был хорошим, и судя по всему многим дал много новой полезной
информации. Народу было не протолкнуться (интересно, а кто слушал доклад
Бена в соседнем зале?).</p>

<p>В частности, этот доклад был для меня еще некоторой пищей для
размышлений, после наблюдения за другими участниками конференции.</p>

<p>Не обошлось на докладе и шуток в сторону Microsoft. Так как все надо
было демонстрировать, и Костя как и обычный человек порой опечатывался,
то выходили и ошибки. На одну из таких ошибок, из зала вылетел довольно
хороший укол в виде &#8220;используй Chrome&#8221;. Зал поржал, а Косте надо отдать
должное - очень стойкий. Молодец.</p>

<p>После двух часов докладов, все отправились на обед. Я особо не буду задерживаться на этом моменте. Впереди меня ждало еще два часа докладов.</p>

<h3>Самый лучший браузер в мире</h3>

<p>Первый из которых я посетил был второй доклад Гайдара Магданурова &#8220;Игры
воображения с новыми API для Javascript&#8221;. В своем докладе, Гайдар
продемонстрировал возможности нового стандарта JS 5, такие как FileAPI,
AppCache, Web workers, HistoryAPI, и другие. Для демонстрации вновь
использовался Node.js.</p>

<p>Кроме того, как бы невзначай, слушатели увидели воочию работу Windows 8.
У Гайдара стояла на машине Windows 8, и он то и дело &#8220;невзначай&#8221;
промахивался, открывая интерфейс Метро. В остальном, Windows 8 была не
отличима от Windows 7. Кстати говоря, судя по тому, что на ней уже
многое работает, она довольно таки production-ready.</p>

<p>Не обошлось без шуток и &#8220;рекламы&#8221;. Шутка &#8220;самый лучший браузер в мире&#8221;
после третьего или четвертого повторения уже не имела никакого эффекта.</p>

<p>Доклад был очень информативен, несмотря на всего лишь базовый обзор
возможностей. Было описано также много подводных камней. Еще раз спасибо Гайдару.</p>

<h3>Все будет хорошо</h3>

<p>Слушать про достижения от компании 1С мне было совсем не интересно, как
и многим другим, судя по моим наблюдениям. Я решил отправиться на доклад
технического директора Keiss Media Павла Криворучко.</p>

<p>Павел поделился историей успеха его компании на рынке поставки HTML
контента, поделился опытом, который они приобрели наступая на грабли во
время разработки множества HTML-игр для мобильных платформ, а также дал
много полезных советов, которые стоило намотать на ус.</p>

<p>Доклад очень ободрил, и дал надежду на будущее, дал не просто надежду,
но и вселил очень большой оптимизм. Оптимизму Павла и его компании можно
только позавидовать.</p>

<p>Самым же ценным советом от Павла мне кажется был его заключительный
совет, заключающийся в призыве использовать HTML5 технологии уже сейчас,
в призыве писать много новых интересных приложений, и если есть удачные
веб-приложения в виде сайтов, то писать для них интересные мобильные
клиенты.</p>

<h3>Топор в спину</h3>

<p>Следующим докладом, на который я заранее планировал попасть был доклад
разработчика интерфейса Я.Почта Алексея Андросова.</p>

<p>Алексей очень хорошо изложил как они используют новые возможности в
сервисе Яндекс.Почты. Прошелся по новым возможностям HTML5, и о том,
какие грабли они встретили на своем пути.</p>

<p>В частности, много было посвящено проблеме WebSocket&#8217;ов, Server-Sent
Events, flash-websocket и long-polling. Тема очень горячая, и очень
интересная, а опыт Яндекс в использовании этих технологий неоценим.</p>

<p>Алексей также рассказал про использование AppCache, о котором ранее в
своем докладе рассказывал Гайдар, и пожаловался на топор в спину Яндекс
со стороны Firefox (да, огненная лисичка подвела их).</p>

<p>По мере доклада, Алексей представил не мало полезных советов, за что ему
огромное спасибо.</p>

<h3>Метро 2023</h3>

<p>После перерыва, все снова собрались в пленарном зале, который уже
объединили, для выступления Владимра Колесникова (еще одного
представителя Microsoft). На этот раз тема была не столь волнующа для
многих, но не менее интересна. Касалась она разработки мобильных
приложений для Windows Phone 7.</p>

<p>В целом, обзор был интересный, хотя местами что-то не получалось. Помимо
стандартного обзора возможностей написания HTML5 приложений для Windows
Phone 7, была продемонстрирована возможность использования PhoneGap для
написания кроссплатформенных приложений с его помощью, а также дан
краткий обзор возможностей использования его вкупе с jQuery Mobile.</p>

<p>Владимир вовремя предостерег от граблей как в использовании PhoneGap,
так и в использовании его вместе с jQuery (так как самые новые их
версии, увы работать вместе не могут).</p>

<p>Также мне понравилась демонстрация возможностей интерфейса Metro, в
частности тайлов.</p>

<p>Ну и в довершении всего Владимир очень хорошо подвел черту под тем,
какой должен быть интерфейс мобильного приложения, чтобы быть удачным, и
иметь успех у пользователя. Советы во многом очевидные, но как всегда и
бывает, все что на поверхности - зачастую забывается и не используется.</p>

<h3>А когда же стандарты?</h3>

<p>В завершении доклада Владимира, его ждал большой &#8220;сюрприз&#8221;. Один из
слушателей, дорвавшись таки до микрофона, задал вопрос, который не знал
кому задать весь день: &#8220;Когда наконец-то Internet Explorer будет
поддерживать стандарты?&#8221;.</p>

<p>Швал аплодисментов был просто бешеный. Владимир с Гайдаром действительно
не нашлись что ответить, и по ним было видно, что они потеряны, а
&#8220;перепалка&#8221; заняла минут пять.</p>

<p>Разрулил ситуацию Костя, очень адекватно и обстоятельно подойдя к
вопросу, прислушавшись к автору вопроса, и попытавшись выйти из трудной
ситуации. Это у него получилось, и это еще один раз, за что ему хочется
отдать должное.</p>

<p>Честно говоря, я думаю каждый сидящий в то время в зале ожидал, когда же
этот вопрос будет задан.</p>

<h3>Ужас летящий на крыльях ночи</h3>

<p>На этом доклады закончились. Онлайн трансляция была завершена, а
участники остались для завершающей части с розыгрышем призов.</p>

<p>Константин Кичинский подготовил простенькую викторину, по которой
разыграли пары памятных пивных кружек с эмблемой Internet Explorer.</p>

<p>Вопросы были в основном по второму докладу Гайдара, но не смотря на это,
были случаи, когда на них не могли ответить. Ну а я замешивался поднять
руку, и как грится проворонил свои памятные призы.</p>

<p>Особенно порадовал первый вопрос: &#8220;Что такое W3C?&#8221;. Ответ одного из
участников был гениальным: &#8220;Такая организация, которая занимается
стандартами&#8221;. Ответ прошел, но Костя на деле подготовил просто
сногсшибательный правильный ответ: &#8220;Консорциум WWW, или ужас летящий на
крыльях ночи&#8221;, чем сорвал куш.</p>

<p>Дополнительные призы в виде веб-камер и компьютерных мышей был разыгран
по анкетам, которые выдавали при регистрации на конференции.</p>

<p>На этом конференция закончилась, все поблагодарили организаторов, и
отправились на фуршет, или прямиком домой, как это сделал я. Конференция
жутко понравилась, было действительно весело и интересно, особенно на
докладах Гайдара, который даже не смотря на возникающие проблемы
подбадривал аудиторию, и всячески старался не дать заскучать, за что ему
отдельное спасибо.</p>

<h3>Общие впечатления</h3>

<p>Общие впечатления от прошедшей конференции у меня крайне положительные.
Мое отношение к этой компании существенно изменилось. Не то, чтобы я
стал лоялен к их продуктам, или проникся желанием стать
Windows-разработчиком, но.</p>

<p>Там действительно работают веселые и позитивные люди, которые как и мы
видят идеальный мир, идеальное ПО, и эти люди открыты и позитивны. Может
быть взгляды и стратегии у нас с ними разные, может быть в обыденной
жизни, мы конкуренты - но на конференции были не &#8220;злые дяди из
Microsoft&#8221;, а очень позитивные и открытые люди, которые пригласили своих
коллег не чтобы провести очередное впаривание своих продуктов, но и
поделиться опытом с другими, и хорошо провести время.</p>

<p>И спасибо им, за этот теплый прием. Если у меня выдастся возможность
попасть на HTML5 Camp в следующий раз - я обязательно сделаю все, чтобы
туда попасть.</p>

<h2>Теперь и выводы по полочкам</h2>

<p>После конференции остались не только приятные впечатления от классных
докладов, позитивных людей, хорошего настроения и теплого приема, но и
осталось довольно много пищи для размышлений, и для подтверждения мыслей
и ощущений связанных с наблюдением за веб-разработкой, как огромной
индустриальной областью.</p>

<p>С одной стороны, на конференции присутствовало много людей, которые были
либо вообще не веб-разработчиками, либо почти ничего не знали о HTML5.</p>

<p>Это и удивительно, и не очень. Я уже честно говоря привык к тому, что
многие веб-разработчики - очень консервативные люди, которые зачастую
просто боятся использовать новые возможности и технологии.</p>

<p>Да. Веб-разработка - это очень вязкая и неоднозначная сфера, в которой
разработка не может вестись без десятка другого костылей, без решения
множества проблем, которые не приносят никакого удовольствия.</p>

<p>И постоянная забота о развитии продуктов, о совместимости браузеров и
многие другие вещи. Все это сделало многих разработчиков -
консерваторами.</p>

<p>Это привело к очень сложной ситуации на рынке. Мало того, что найти
веб-разработчика (я не имею ввиду PHP CMS&#8217;о настройщиков), я имею ввиду
именно веб-разработчика (PHP, Python или Ruby, а может Java - не важно),
так еще меньше из этих разработчиков не являются консерваторами.</p>

<p>Тем временем, существует большое количество прогрессивных разработчиков,
которые двигают отрасль вперед, не боятся новых возможностей, и как
можно больше придумывают ногово. Но их все равно несоизмеримо меньше.</p>

<p>Это создает очень большой разлом, между используемыми технологиями и
накопленным опытом, и между технологиями, которые появились недавно,
требуют много внимания, активного внедрения и использования, &#8220;обкатки&#8221;
если хотите.</p>

<p>Учитывая, что мы сейчас стоим действительно на пороге революции в вебе -
я даже не боюсь сказать, что это будет не Web 2.0, и не Web 3.0, это
будет что-то совершенно новое (эти мои мысли однозначно подтверждает и
то, что гиганты индустрии кинулись в эту область разом), такой разброд,
такая &#8220;разладка&#8221;, такой разлом не играет отрасли на руку.</p>

<p>Кто-то так и останется навсегда позади, кто-то уже впереди, а у кого-то
еще есть возможность встать на гребень волны. И эту возможность нельзя
упускать ни в коем случае.</p>

<p>Что еще хочется сказать от себя. HTML5 требует новых решений, нового
опыта, и глобальные изменения претерпят не только инструменты разработки
клиентской части приложения, но эти изменения во многом требуют кореных
и очень сильных решений в разработке серверных решений, и таких решений
пока очень мало, и они очень нужны. И опять таки, открывается очень
большой простор.</p>

<p>Настает момент еще большей фрагментации и более узкой специализации
веб-разработчиков. А сама веб-разработка, несмотря на мнение многих,
становится не менее сложным занятием, чем разработка сложных технологий,
например в области операционных систем, каких-то серверов, или
математических вычислений. Сложность веб-разработки растет с каждым
днем, и очень радует, что веб-разработчики более ленивы, и стараются
создать инструменты, которые максимально стараются облегчить жизнь, так
как жизнь итак усложняется непомерным количеством костылей, и других
проблем.</p>

<p>И да. Веб-разработка выходит на первое место. Нравится кому или нет, это
сейчас наиболее приоритетная область, которая будет двигать очень
большой пласт остальных отраслей IT.</p>

<p>Еще один момент, который совершенно не радует: вся эта суматоха, весь
этот сумасшедший ритм приводит к тому, что новые возможности стараются
внедрять многие, но многие это делают просто бездумно. Как уже сегодня
эта тема обсуждалась мной в Juick, то я приведу очень яркий пример:
Unity и Gnome 3. И если Unity еще очень отдаленный пример такого
стремления и непонимания, и ее разработчики очень аккуратно проходят
минное поле, то разработчики Gnome 3 собирают на минном поле все мины.
Это яркий пример того, как люди начинают замечать новые тренды, новые
возможности, но не знают как правильно их использовать. И это очень
плачевно.</p>

<h2>ПЫ СЫ</h2>

<p>Фотографий с конференции не будет, так как ваш покорный слуга не
фотографировал, а следовало бы.</p>

<p>Ну и простите за столь объемный пост, и столь сумбурные мысли. Я
старался собрать в голове все впечатления как от конференции, так и свои
ранние мысли в одно, и поделиться с вами. Не судите строго.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A successfull Git branching model]]></title>
    <link href="http://demiazz.github.com/blog/2011/11/19/a-successfull-git-branching-model/"/>
    <updated>2011-11-19T15:25:00+04:00</updated>
    <id>http://demiazz.github.com/blog/2011/11/19/a-successfull-git-branching-model</id>
    <content type="html"><![CDATA[<p>Система управления версиями Git заняла прочные позиции на рынке. Как и любая система управления версиями, Git подразумевает поиск и использование более удобных и простых подходов к организации работы с исходным кодом, и его контролю.</p>

<p>Еще в начале 2010 года, Vincent Driessen написал статью, в которой описал опыт использования Git, и обобщил свой опыт в виде модели использования веток при организации хранения кода под управлением Git.</p>

<p>Свою статью он опубликовал по в своем блоге, и ее можно почитать в оригинале: <a href="http://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a>.</p>

<p>В данном посте, я приведу свой немного вольный перевод этой статьи.</p>

<!-- more -->


<p>Предлагаемая модель управления исходным кодом, с использованием Git, успешно использовалась автором на всех его проектах (рабочих, и собственных). В статье не говорится о деталях проектов, а статья содержит лишь описание модели, которую автор с успехом применяет в повседневной разработке программного обеспечения.</p>

<p><img class="center" src="http://demiazz.github.com/images/posts/a-successful-git-branching-model/1.png" title="Общая схема ветвления" ></p>

<p>Данная модель позволяет использовать Git именно как инструмент для контроля версий, в контексте разработки программного обеспечения.</p>

<h2>Почему Git?</h2>

<p>Данная статья не о Git как таковом, не о его преимуществах и недостатках. Эта статья лишь описывает одну из моделей разработки проекта, с применением особенностей Git.</p>

<p>Модель предложенная автором статьи базируется на особенностях работы Git с ветками версий. Для сравнения, если рассматривать классические централизованные системы контроля версий, такие как CVS/SVN, то можно увидеть более консервативный и осторожный подход к использованию веток, а также их объединения. Данные операции являются тяжелыми и сложными, а в любой книге, посвященной данным системам, такие операции описываются в разделе предназначенном для опытных пользователей. Зачастую, операции создания и объединения веток в репозитории являются привилигированными операциями, и разработчики не имеют к ним доступа.</p>

<p>Распределенные системы контроля версий, такие как Git, напротив, базируются на идее активного использования веток, их создания и объединения. Это позволило создать еще одну эффективную модель разработки, которая отлично подходит как для разработчика-одиночки, так и для командной разработки.</p>

<p>Что касается самой модели, то это не панацей, не великое открытие. Это всего лишь набор процедур и подходов, придерживаясь которых можно сделать процесс разработки ПО управляемым. Конечно, чтобы данная модель принесла свои плоды, требуется четкое соблюдение процедуры не отдельными разработчиками, а каждым участником команды. Как показала практика, и опыт применения этой модели автором на реальных проектах, модель является весьма жизнеспособной и эффективной.</p>

<h2>Децентрализованные, но централизованные</h2>

<p>Несмотря на долгое существование Git на рынке, как и децентрализованных систем управления версиями, до cих пор имеет место путаница в связи с централизованностью.</p>

<p>При разработке с использованием Git, всегда создается единый центральный репозиторий. С технической точки зрения, этот репозиторий не является центральным, так как такого понятия в Git просто не существует. Разделение на центральный, и остальные репозитории является чисто логическим, и завязано на соглашениях в конкретном проекте и команде. Центральный репозиторий, с которым работает команда, обычно называется <code>origin</code>.</p>

<p><img class="center" src="http://demiazz.github.com/images/posts/a-successful-git-branching-model/2.png" title="Пример &#34;централизованности&#34; Git" alt="Пример &#34;централизованности&#34; Git"></p>

<p>Каждый разработчик используя <code>push</code> и <code>pull</code> может в двустороннем порядке обмениваться изменениями между своим локальным репозиторием и <code>origin</code>. Но, кроме двунаправленного обмена между указанными хранилищами, возможен также двусторонний обмен с хранилищами других разработчиков. Это может быть полезно, когда в проекте, над разработкой какого-либо функционала работают несколько разработчиков. Во время разработки, эти изменения не должны попадать в <code>origin</code>, но в то же время, должен происходить обмен изменениями, произведенными каждым из разработчиков. В этом случае, разработчики обмениваются изменениями между своими локальными репозиториями, не затрагивая код в <code>origin</code>.</p>

<p>На рисунке выше показан пример такой организации работы. В команде четыре разработчика. Каждый из них имеет доступ к <code>origin</code>, но помимо этого можно выделить три группы разработчиков, которые обмениваются изменениями только между собой: Алиса и Боб, Алиса и Дэвид, Клер и Дэвид.</p>

<p>С технической стороны, это означает, что к примеру Алиса работает с двумя удаленными репозиториями: <code>origin</code> и <code>bob</code> (который принадлежит Бобу), и наоборот.</p>

<h2>Главные ветки</h2>

<p><img class="right" src="http://demiazz.github.com/images/posts/a-successful-git-branching-model/3.png" title="&#34;Главные ветки&#34;" alt="&#34;Главные ветки&#34;"></p>

<p>Представленная модель в значительной степени вдохновлена уже существующими моделями. Центральное хранилище предоставляет две ветки с бесконечным жизненным циклом:</p>

<ul>
<li><code>master</code></li>
<li><code>develop</code></li>
</ul>


<p>Ветка <code>master</code> в хранилище <code>origin</code> знакома каждому пользователю Git. Паралелльно с веткой <code>master</code>, существует другая ветка, называемая <code>develop</code>.</p>

<p>Ветка <code>origin/master</code> мы рассматриваем как главную ветку, <code>HEAD</code> в которой, всегда указывает на <em>production ready</em> состояние.</p>

<p>Ветка <code>origin/develop</code> рассматривается как главная ветка, в которой <code>HEAD</code> отражает состояние исходного кода, на момент последних изменений, подготовленных к следующему релизу. Некоторые называют эту ветку <em>integration branch</em>. Например, <code>HEAD</code> этой ветки используется для ночных сборок.</p>

<p>Когда исходный код в ветке <code>develop</code> достигает стабильности, и содержит уровень функциональности близкий к желаемому, все изменения из <code>develop</code> должны быть внесены обратно в <code>master</code>, и отмечены тегом соответствующего релиза.</p>

<p>Исходя из всего вышесказанного, можно заявить, что каждое внесение изменений в <code>master</code>, является очередным релизом по определению. Если строго подходить к этим рекомендациям, то теоретически, можно использовать <em>хук(hook)</em> к скрипту Git, для автоматической сборки и развертывания ПО на production-серверах, после каждого коммита в <code>master</code>.</p>

<h2>Дополнительные ветки</h2>

<p>В предлагаемой модели, помимо двух главных веток (<code>master</code> и <code>develop</code>), также используются вспомогательные ветки, которые позволяют облегчить ведение параллельной разработки членами команды, слежение за спектром разрабатываемого функционала проекта, подготовку к релизам, а также помогают в решении проблем, которые возникают в production коде. Но в отличии от главных веток, эти ветки имеют ограниченное время жизни, так как рано или поздно будут удалены.</p>

<p>В качестве основных вспомогательных типов веток могут быть выделены:</p>

<ul>
<li>ветки <code>feature</code></li>
<li>ветки <code>release</code></li>
<li>ветки <code>hotfix</code></li>
</ul>


<p><em>(Оригинальные названия типов веток сохранены намерено, во измежание путаницы в переводе. Прим. перев.)</em></p>

<p>Каждый из этих типов веток имеет конкретные цели и правила работы с ними. Для них строго определены те ветки, от которых можно произвести ветвление, и с какими ветками должны быть объединены. И опять же, во избежание введения в заблуждение, стоит оговориться, что эти ветки никак не являются &#8220;специальными&#8221; с технической точки зрения. Это обычные ветки Git. Их типизация зависит от правил, которые придерживаются при работе с ними.</p>

<h3>Ветки <code>feature</code></h3>

<p><img class="right" src="http://demiazz.github.com/images/posts/a-successful-git-branching-model/4.png" title="Ветки feature" ></p>

<p>Правила ветвления, слияния и именования:</p>

<ul>
<li>Эти ветки наследуются только от <code>develop</code>;</li>
<li>Эти ветки должны сливаться обратно с <code>develop</code>;</li>
<li>Имя ветки может быть любым, кроме <code>master</code>, <code>develop</code>, <code>release-*</code>, <code>hotfix-*</code>.</li>
</ul>


<p>В ветках <code>feature</code> ведется разработка функционала для будущих релизов проекта. На момент начала работы над новым функционалом, релиз в котором он появится может быть и неизвестен. Суть таких веток в том, что разработка новых функциональных возможностей может вестись параллельно разработке основной части проекта, а по завершении реализации нового функционала он может быть внедрен в одном из следующих версий, либо отклонен (в случае, если функционал не удовлетворяет целям проекта, либо по каким-либо другим причинам). Такие ветки должны создаваться в локальных репозиториях разработчиков, но ни в коем случае не в <code>origin</code>.</p>

<h4>Создание ветки <code>feature</code></h4>

<p>Для создания ветки <code>feature</code>:</p>

<figure class='code'><figcaption><span>Создание ветки `feature`  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>git checkout -b myfeature develop
</span><span class='line'>Switched to a new branch <span class="s2">&quot;myfeature&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>При создании ветки <code>feature</code> ветвление осуществляется от <code>develop</code>.</p>

<h4>Конец жизненного цикла ветки <code>feature</code></h4>

<p>Законченный функционал может быть объединен обратно с веткой <code>develop</code> для добавления его в следующий релиз:</p>

<figure class='code'><figcaption><span>Слияние `feature` ветки в `develop`  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>git checkout develop
</span><span class='line'>Switched to branch <span class="s1">&#39;develop&#39;</span>
</span><span class='line'><span class="nv">$ </span>git merge --no-ff myfeature
</span><span class='line'>Updating ea1b82a..05e9557
</span><span class='line'><span class="o">(</span>Summary of changes<span class="o">)</span>
</span><span class='line'><span class="nv">$ </span>git branch -d myfeature
</span><span class='line'>Deleted branch myfeature <span class="o">(</span>was 05e9557<span class="o">)</span>.
</span><span class='line'><span class="nv">$ </span>git push origin develop
</span></code></pre></td></tr></table></div></figure>


<p>Использование флага <code>--no-ff</code> создает новый коммит, который содержит все изменения сливаемой ветки. Это позволяет избежать потери информации о существовании ветки, в которой велась разработка добавленного функционала. Для сравнения, взгляните на изображение ниже. Слева слияние с использованием флага <code>--no-ff</code>, справа без него:</p>

<p><img class="center" src="http://demiazz.github.com/images/posts/a-successful-git-branching-model/5.png" title="Сравнение слияния веток с флагом --no-ff и без" ></p>

<p>Как видно, если не указать флаг &#8211;no-ff, изменения которые делались в ветке <code>feature</code>, невозможно будет увидеть. Это чревато тем, что для того, чтобы увидеть все изменения сделанные в ветке <code>feature</code>, придется перечитать все сообщения журнала, и выбирать именно те коммиты, которые касаются интересующих изменений. Отмена изменений ветки <code>feature</code> также становится настоящей головной болью, тогда как <code>--no-ff</code> упрощает эту задачу, ведь откатить придется всего лишь один коммит. Хотя именно такое поведение более предпочтительною</p>

<p><em>Для установки такого поведения слияния по умолчанию, можно заставить Git использовать <code>--no-ff</code> по умолчанию, путем правки <code>.gitconfig</code>, и добавления следующих строк:</em></p>

<figure class='code'><figcaption><span>Включение &#8211;no-ff по умолчанию  </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[alias]
</span><span class='line'>merge=merge --no-ff</span></code></pre></td></tr></table></div></figure>


<h3>Ветки <code>release</code></h3>

<p>Правила ветвления, слияния и именования:</p>

<ul>
<li>Ветвление этих веток может быть произведено только от <code>develop</code>;</li>
<li>Эти ветки должны сливаться обратно в <code>develop</code> и в <code>master</code>;</li>
<li>Имя ветки должно быть формата <code>release-*</code>.</li>
</ul>


<p>Ветки <code>release</code> используются при подготовке к выпуску очередного релиза. Они позволяют в самую последнюю минуту расставить все точки над i. Кроме того, они позволяют вносить исправления мелких ошибок, и подготовить метаданные для релиза (номер версии, дата создания и т.д.). Делая все эти действия в ветках <code>release</code>, ветка <code>develop</code> останется чиста, и будет готова к добавлению нового кода, отвечающего непосредственно за расширение функционала разрабатываемого продукта.</p>

<p>Создание ветки <code>release</code> производится в тот момент, когда состояние кода в <code>develop</code> отражает желаемое состояние нового релиза. По крайней мере, весь запланированный функционал ожидаемый в релизе, уже должен быть в <code>develop</code> ветке. Весь оставшийся код, отвечающий за расширение функционала, и отложенный на будущие релизы, должен ожидать, пока не будет выпущен релиз.</p>

<p>Именно при создании <code>release</code> ветки, релиз получает номер версии, а не раньше. До этого момента, в ветке <code>develop</code> отражены изменения запланированные для выпуска в следующем релизе, но станет ли следующий релиз <code>0.3</code> или <code>0.1</code> неизвестно до создания ветки <code>release</code>. Присвоение релизу номера версии происходит в момент создания <code>release</code>. Присвоение релизу номера версии происходит в момент создания <code>release</code> ветки, и следует правилам нумерации, которые предложены в проекте.</p>

<h4>Создание ветки <code>release</code></h4>

<p>Ветки <code>release</code> создаются ветвлением от <code>develop</code>. Создание такой ветки покажем на примере. Пускай версия <code>1.1.5</code> - это текущий production релиз, и мы приближаемся к следующему большому релизу. Состояние ветки <code>develop</code> говорит о готовности к следующему релизу, и мы решили, что это будет <code>1.2</code>, а не <code>1.1.6</code> или <code>2.0</code>. Теперь, мы создаем ветку, и даем ей имя отображающее номер релиза:</p>

<figure class='code'><figcaption><span>Создание ветки `release`  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>git checkout -b release-1.2 develop
</span><span class='line'>Switched to a new branch <span class="s2">&quot;release-1.2&quot;</span>
</span><span class='line'><span class="nv">$ </span>./bump-version.sh 1.2
</span><span class='line'>Files modified successfully, version bumped to 1.2.
</span><span class='line'><span class="nv">$ </span>git commit -a -m <span class="s2">&quot;Bumped version number to 1.2&quot;</span>
</span><span class='line'><span class="o">[</span>release-1.2 74d9424<span class="o">]</span> Bumped version number to 1.2
</span><span class='line'>1 files changed, 1 insertions<span class="o">(</span>+<span class="o">)</span>, 1 deletions<span class="o">(</span>-<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>После создания новой ветки, и переключения на нее, мы изменяем везде номер версии на новый. К примеру это могут быть номера версии в исходных файлах проекта, в параметрах сборки executable файла, или еще что-то. В примере выше, это автоматизировано, и для этой цели используется вымышленный скрипт bump-version.sh, который производит нужные изменения в файлах рабочей директории, для отображения состояния новой версии. Это конечно может быть произведено и в ручную. В нашем примере, мы используем некий абстрактный проект. После этого заносим изменения в RB.</p>

<p>После создания новой ветки, и переключения на нее, мы изменяем везде номер версии на новый. К примеру, это могут быть номера версии в исходных файлах проекта, в параметрах сборки выполняемого файла, или еще что-то. В примере выше, это автоматизировано, и для этой цели используется вымышленный скрипт <code>bump-version.sh</code>, который производит нудные изменения в файлах рабочей директории, для отображения состояния новой версии. Это конечно может быть произведено и в ручную. В нашем примере, мы используем некий абстрактный проект. После этого заносим изменения в ветку <code>release</code>.</p>

<p>Этот процесс очень похож на выпуск так называемой бета-версии, когда производится только тестирование продукта, поиск и исправление ошибок, но уже никакой новый функционал не добавляется.</p>

<h4>Закрытие ветки <code>release</code> и выпуск релиза</h4>

<p>Когда состояние кода в ветке <code>release</code> готово к выпуску релиза, необходимо провести некоторые действия. Во-первых, нужно влить ветку <code>release</code> обратно в <code>master</code> (напомним еще раз, что каждый коммит в <code>master</code> - это новый релиз по определению). Далее, сделанный коммит следует отметить тегом, отображающим номер версии, что поможет в будущем легче ориентироваться в релизах. И наконец, изменения сделанные в ветке <code>release</code> должны быть слиты обратно в <code>develop</code>, так чтобы будущее релизы содержали все исправления, сделанные в процессе подготовки релиза.</p>

<p>Первые два шага в Git:</p>

<figure class='code'><figcaption><span>Выпуск релиза  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>git checkout master
</span><span class='line'>Switched to branch <span class="s1">&#39;master&#39;</span>
</span><span class='line'><span class="nv">$ </span>git merge --no-ff release-1.2
</span><span class='line'>Merge made by recursive.
</span><span class='line'><span class="o">(</span>Summary of changes<span class="o">)</span>
</span><span class='line'><span class="nv">$ </span>git tag -a 1.2
</span></code></pre></td></tr></table></div></figure>


<p>Релиз выпущен, и помечен для будущего использования.</p>

<p>Для того, чтобы сохранить изменения сделаные в ветке <code>release</code>, нужно слить их обратно в <code>develop</code>:</p>

<figure class='code'><figcaption><span>Слияние `release` ветки в `develop`  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>git checkout develop
</span><span class='line'>Switched to branch <span class="s1">&#39;develop&#39;</span>
</span><span class='line'><span class="nv">$ </span>git merge --no-ff release-1.2
</span><span class='line'>Merge made by recursive.
</span><span class='line'><span class="o">(</span>Summary of changes<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Этот шаг может привести к конфликтам во время слияния. Если такое произойдет, то следует исправить конфликты, и зафиксировать изменения.</p>

<p>Теперь релиз полностью выпущен, и <code>release</code> ветка может быть удалена, так как она нам больше не нужна:</p>

<figure class='code'><figcaption><span>Удаление ветки `release`  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>git branch -d release-1.2
</span><span class='line'>Deleted branch release-1.2 <span class="o">(</span>was ff452fe<span class="o">)</span>.
</span></code></pre></td></tr></table></div></figure>


<h3>Ветки <code>hotfix</code></h3>

<p><img class="right" src="http://demiazz.github.com/images/posts/a-successful-git-branching-model/6.png" title="Ветки `hotfix`" ></p>

<p>Правила ветвления, слияния и именования:</p>

<ul>
<li>Ветвление этих веток может быть произведено только от <code>master</code>;</li>
<li>Эти ветки должны объединяться обратно с <code>develop</code> и <code>master</code>;</li>
<li>Имя ветки должно быть формата <code>hotfix-*</code>.</li>
</ul>


<p>Ветки <code>hotfix</code> очень похожи на ветки <code>release</code> в том, что они также предназначены для подготовки к новым релизам, хотя и не запланированным. Они возникают, из-за необходимости действовать сразу же после обнаружения серьезной ошибки в production коде. Когда критическая ошибка в production версии должна быть разрешена немедленно, <code>hotfix</code> может быть создана ветвлением от коммита в ветке <code>master</code> с меткой текущей production версии.</p>

<p>Использование такого перехода заключается в том, что члены команды смогут дальше продолжать решение поставленных задач (в ветке <code>develop</code>), в то время как ответственный разработчик будет готовить исправление ошибки в production версии.</p>

<h4>Создание ветки <code>hotfix</code></h4>

<p>Ветка <code>hotfix</code> создается ветвлением от ветки <code>master</code>. Рассмотрим небольшой пример. Допустим, версия <code>1.2</code> является текущей production версией, которая сейчас используется и вызывает проблемы из-за нескольких досадных и неприятных ошибок в коде. Изменения в ветке <code>develop</code> пока нестабильные, чтобы делать новый релиз. В таком случае, мы ветвлением от <code>master</code> создает ветку <code>hotfix</code> и начинаем исправлять ошибку в рамках этой ветки:</p>

<figure class='code'><figcaption><span>Создание ветки `hotfix`  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>git checkout -b hotfix-1.2.1 master
</span><span class='line'>Switched to a new branch <span class="s2">&quot;hotfix-1.2.1&quot;</span>
</span><span class='line'><span class="nv">$ </span>./bump-version.sh 1.2.1
</span><span class='line'>Files modified successfully, version bumped to 1.2.1.
</span><span class='line'><span class="nv">$ </span>git commit -a -m <span class="s2">&quot;Bumped version number to 1.2.1&quot;</span>
</span><span class='line'><span class="o">[</span>hotfix-1.2.1 41e61bb<span class="o">]</span> Bumped version number to 1.2.1
</span><span class='line'>1 files changed, 1 insertions<span class="o">(</span>+<span class="o">)</span>, 1 deletions<span class="o">(</span>-<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Не забывайте применить изменения версии после ответвления!</p>

<p>После, исправляем ошибку и фиксируем исправление одним или несколькими коммитами.</p>

<figure class='code'><figcaption><span>Фиксация изменений  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>git commit -m <span class="s2">&quot;Fixed severe production problem&quot;</span>
</span><span class='line'><span class="o">[</span>hotfix-1.2.1 abbe5d6<span class="o">]</span> Fixed severe production problem
</span><span class='line'>5 files changed, 32 insertions<span class="o">(</span>+<span class="o">)</span>, 17 deletions<span class="o">(</span>-<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Закрытие ветки <code>hotfix</code> и выпуск внеочередного релиза</h4>

<p>После исправления ошибки, нужно слить ветку <code>hotfix</code> обратно в ветку <code>master</code>, но также требуется объединить эту ветку обратно с <code>develop</code>, с тем, чтобы гарантировать, что исправления будут доступны и в последующих релизах. Эти действия аналогичны закрытию ветки <code>release</code>.</p>

<p>Обновим ветку <code>master</code> и тег релиза.</p>

<figure class='code'><figcaption><span>Обновление `master` и тега релиза  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>git checkout master
</span><span class='line'>Switched to branch <span class="s1">&#39;master&#39;</span>
</span><span class='line'><span class="nv">$ </span>git merge --no-ff hotfix-1.2.1
</span><span class='line'>Merge made by recursive.
</span><span class='line'><span class="o">(</span>Summary of changes<span class="o">)</span>
</span><span class='line'><span class="nv">$ </span>git tag -a 1.2.1
</span></code></pre></td></tr></table></div></figure>


<p>Затем, занесем исправление в ветку <code>develop</code>:</p>

<figure class='code'><figcaption><span>Занесение изменений в ветку `develop`  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>git checkout develop
</span><span class='line'>Switched to branch <span class="s1">&#39;develop&#39;</span>
</span><span class='line'><span class="nv">$ </span>git merge --no-ff hotfix-1.2.1
</span><span class='line'>Merge made by recursive.
</span><span class='line'><span class="o">(</span>Summary of changes<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Из правила работы с ветками <code>hotfix</code> есть одно исключение: если ветка <code>release</code> уже существует, изменения ветки <code>hotfix</code> должны быть слиты обратно в ветку <code>release</code>, исключая при этом ветку <code>develop</code>. Слияние с веткой <code>release</code> приведет к тому, что после выпуска релиза, исправление будет также доступно и в ветке <code>develop</code>. (Если работа в <code>develop</code> требует немедленного исправления, и не может ждать пока будет выпущен релиз, можно безопасно занести исправление и в <code>develop</code>).</p>

<p>В конце, удаляем ветку <code>hotfix</code>:</p>

<figure class='code'><figcaption><span>Удаление ветки `hotfix`  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>git branch -d hotfix-1.2.1
</span><span class='line'>Deleted branch hotfix-1.2.1 <span class="o">(</span>was abbe5d6<span class="o">)</span>.
</span></code></pre></td></tr></table></div></figure>


<h2>Подведем итоги</h2>

<p>Предложенная модель в чем-то может показаться знакомой, и может сложиться ощущение, что автор изобрел велосипед. На самом деле, автор объединил существующие подходы, очевидные вещи в единую логичную системы и подвел черту. Данная модель не является серебрянной пулей, но она проста, наглядна и легка в применении. Модель отлично подходит для тех проектов, где используется Git. Также, данная модель помогает развить понимание ветвления и процесса выпуска релизов.</p>
]]></content>
  </entry>
  
</feed>
